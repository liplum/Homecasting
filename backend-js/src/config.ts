import fs from "fs/promises"
import { v4 as uuidv4 } from "uuid"
import { type File } from "./file.js"
import JSON5 from "json5"
import yaml from "yaml"
import * as  R from "./r.js"
import mime from "mime"
import os from "os"
export interface AppConfig {
  /**
   * It indicates whether the config file is readonly, aka, the file cannot be modified by Meditree.
   * false by default.
   */
  readonly?: boolean
  /** 
   * The network interface on which the application will listen for incoming connections.
   * 0.0.0.0(all interfaces) by default.
   */
  hostname?: string
  /** 
   * Port 80 is used by default.
   */
  port: number
  /**
   * The root directory to host.
   *
   * By default, no local file tree will be created.
   * 
   * If an array of paths is given, a virtual file tree will be created with the given paths.
   * 
   * If a map of name to path is given, a virtual file tree will be created with the specified names and paths.
   */
  root?: string | string[] | Record<string, string>
  /**
   * The root directory where to save the uploaded files.
   * 
   * By default, if the {@link root} 
   */
  storageRoot?: string
  /**
   * Recognizing the mime type most precisely by reading the file's magic number.
   * It will terribly impact the performance of building file tree.
   * false by default.
   */
  enhancedMimeType?: boolean
  /**
   * The unique name of hosted file tree.
   * A uuid v4 will be generated by default.
   */
  name: string
  /**
   * Minimatch pattern to content type.
   */
  mimeTypes?: Record<string, string>
  /**
   * The included content type.
   * Null and undefined means including all files.
   * undefined by default.
   */
  includes?: string[]
  /**
   * Plugin name/url to its configuration.
   */
  plugin?: Record<string, Record<string, any> | boolean>
  ignore: string[]
  /**
   * 7 days by default.
   */
  cacheMaxAge: number
  /**
   * The minimum log level for console logging.
   * Auto-capitalized.
   * "INFO" by default.
   */
  logLevel?: string
}

export function setupConfig(config: AppConfig | Partial<AppConfig> = {}): AppConfig {
  const newConfig = config as AppConfig
  if (!newConfig.name) {
    newConfig.name = uuidv4()
  }
  if (!newConfig.port) {
    newConfig.port = 8080
  }
  if (!newConfig.ignore) {
    newConfig.ignore = []
    // default to ignore application on macOS
    if (process.platform === "darwin") {
      newConfig.ignore.push(
        "**/*.app",
        "**/*.DS_Store"
      )
    }
  }
  if (newConfig.cacheMaxAge === undefined) {
    newConfig.cacheMaxAge = 604800
  }
  return newConfig
}

enum ConfigFileType {
  json = "application/json", yaml = "text/yaml",
}

const readConfig = (content: string, type: ConfigFileType): any => {
  if (type == ConfigFileType.json) {
    return JSON5.parse(content)
  } else {
    return yaml.parse(content)
  }
}

const writeConfig = async (configFi: File, config: Record<string, any> | string, fileType: ConfigFileType) => {
  if (typeof config === "string") {
    if (fileType === ConfigFileType.yaml) {
      if (!config.startsWith(R.configYamlSchemaComment)) {
        config += `${R.configYamlSchemaComment}${os.EOL}`
        await fs.writeFile(configFi.path, config)
      }
    } else {
      await fs.writeFile(configFi.path, config)
    }
  } else if (fileType === ConfigFileType.json) {
    if (!config["$schema"]) {
      config["$schema"] = R.configJsonSchemaUrl
    }
    await fs.writeFile(configFi.path, JSON.stringify(config, null, 2))
  } else if (fileType === ConfigFileType.yaml) {
    let content = yaml.stringify(config)
    content = `${R.configYamlSchemaComment}\n` + content
    await fs.writeFile(configFi.path, content)
  }
}

export const loadConfigFromFile = async (configFi: File): Promise<AppConfig> => {
  const mimeType = mime.getType(configFi.path)
  const fileType = mimeType === "text/yaml"
    ? ConfigFileType.yaml
    : mimeType === "application/json"
      ? ConfigFileType.json
      : null
  if (!fileType) {
    return setupConfig()
  }

  if (!await configFi.checkReadable()) {
    const config = setupConfig()
    return config
  }

  var content = await fs.readFile(configFi.path, "utf8")
  let config: any
  try {
    const json = readConfig(content, fileType)
    config = setupConfig(json)
  } catch {
    config = setupConfig()
    if (await configFi.checkWritable()) {
      await writeConfig(configFi, config, fileType)
    }
  }

  if (!config.readonly && await configFi.checkWritable()) {
    if (fileType === ConfigFileType.yaml) {
      if (!content.startsWith(R.configYamlSchemaComment)) {
        await writeConfig(configFi, content, fileType)
      }
    } else {
      if (!config["$schema"]) {
        config["$schema"] = R.configJsonSchemaUrl
      }
      await writeConfig(configFi, config, fileType)
    }
  }
  return config
}
