import fs from "fs/promises"
import { v4 as uuidv4 } from "uuid"
import JSON5 from "json5"
import yaml from "yaml"
import * as  R from "./r.js"
import mime from "mime"
import os from "os"
export interface MeditreeConfig {
  /** 
   * The network interface on which the application will listen for incoming connections.
   * 0.0.0.0(all interfaces) by default.
   */
  hostname?: string
  /** 
   * Port 80 is used by default.
   */
  port: number
  /**
   * The root directory to host.
   *
   * By default, no local file tree will be created.
   * 
   * If an array of paths is given, a virtual file tree will be created with the given paths.
   * 
   * If a map of name to path is given, a virtual file tree will be created with the specified names and paths.
   */
  root?: string | string[] | Record<string, string>
  /**
   * Recognizing the mime type most precisely by reading the file's magic number.
   * It will terribly impact the performance of building file tree.
   * false by default.
   */
  enhancedMimeType?: boolean
  /**
   * The unique name of hosted file tree.
   * A uuid v4 will be generated by default.
   */
  name: string
  /**
   * Minimatch pattern to content type.
   */
  mimeTypes?: Record<string, string>
  /**
   * The included content type.
   * Null and undefined means including all files.
   * undefined by default.
   */
  includes?: string[]
  /**
   * Plugin name/url to its configuration.
   */
  plugin?: Record<string, Record<string, any> | boolean>
  ignore: string[]
  /**
   * 7 days by default.
   */
  cacheMaxAge: number
  /**
   * The minimum log level for console logging.
   * Auto-capitalized.
   * "INFO" by default.
   */
  logLevel?: string
}

export function setupConfig(config: MeditreeConfig | Partial<MeditreeConfig> = {}): MeditreeConfig {
  const newConfig = config as MeditreeConfig
  if (!newConfig.name) {
    newConfig.name = uuidv4()
  }
  if (!newConfig.port) {
    newConfig.port = 8080
  }
  if (!newConfig.ignore) {
    newConfig.ignore = []
    // default to ignore application on macOS
    if (process.platform === "darwin") {
      newConfig.ignore.push(
        "**/*.app",
        "**/*.DS_Store"
      )
    }
  }
  if (newConfig.cacheMaxAge === undefined) {
    newConfig.cacheMaxAge = 604800
  }
  return newConfig
}

enum ConfigFileType {
  json = "application/json", yaml = "text/yaml",
}

const readConfig = (content: string, type: ConfigFileType): any => {
  if (type == ConfigFileType.json) {
    return JSON5.parse(content)
  } else {
    return yaml.parse(content)
  }
}

const writeConfig = async (path: string, config: Record<string, any> | string, fileType: ConfigFileType) => {
  if (typeof config === "string") {
    if (fileType === ConfigFileType.yaml) {
      if (!config.startsWith(R.configYamlSchemaComment)) {
        config = `${R.configYamlSchemaComment}${os.EOL}\n` + config
        await fs.writeFile(path, config)
      }
    } else {
      await fs.writeFile(path, config)
    }
  } else if (fileType === ConfigFileType.json) {
    if (!config["$schema"]) {
      config["$schema"] = R.configJsonSchemaUrl
    }
    await fs.writeFile(path, JSON.stringify(config, null, 2))
  } else if (fileType === ConfigFileType.yaml) {
    let content = yaml.stringify(config)
    content = `${R.configYamlSchemaComment}\n` + content
    await fs.writeFile(path, content)
  }
}

export const createConfigFile = async (path: string): Promise<void> => {
  const mimeType = mime.getType(path)
  const initialConfig = setupConfig()
  await writeConfig(path, initialConfig, mimeType === "text/yaml"
    ? ConfigFileType.yaml
    : mimeType === "application/json"
      ? ConfigFileType.json
      : ConfigFileType.json
  )
}

export const loadConfigFromFile = async (path: string): Promise<MeditreeConfig | undefined> => {
  const mimeType = mime.getType(path)
  const fileType = mimeType === "text/yaml"
    ? ConfigFileType.yaml
    : mimeType === "application/json"
      ? ConfigFileType.json
      : ConfigFileType.json
  if (!fileType) {
    return setupConfig()
  }

  try {
    const content = await fs.readFile(path, "utf8")
    const json = readConfig(content, fileType)
    return setupConfig(json)
  } catch {
    return
  }
}

